import java.util.concurrent.ThreadLocalRandom;



/*
 * TO WHOEVER IMPLEMENTS THIS INTO THE PROGRAM:
 * STEPS:
 * 1. call the Generate() function.
 * 2. scroll down, and change print to print to the file, not the command line
 */
public class TempGenerator{
	final static int N = 10; 		// SIZE OF MAP. CHANGE IF NEEDED
	final static int M = 10;
	public static char[][] map = new char[N][M];
	static int Y;
	static int X;
	static int testY;
	static int testX;
	static int delta;
	static String direction;
	static int boxes;
	static int walks; // number of directional walks for each box
	
	public boolean validStartFlag;
	public int randomStartX,randomStartY,randomWayX,randomWayY,randomTX,randomTY;
	public int wallDestroyed;
	
	
	public TempGenerator(int boxNeeded){
		setAllWall();
		generate(boxNeeded);
		this.validStartFlag = false;
		this.randomStartX = 0;
		this.randomStartY = 0;
		this.randomWayX = 0;
		this.randomWayY = 0;
		this.randomTX = 0;
		this.randomTY = 0;
		this.wallDestroyed = 0;
	}	
	public void setAllWall(){
		for (int n=0;n<N;n++){
			for(int m=0;m<M;m++){
				map[n][m] = 'W';
			}
		}
		
	}
	
	public void generate(int boxNeeded){
		int boxSum =0;
		//set player & box binded at start 
		randomStartX = (int )(Math.random() * 6)+2;
		randomStartY = (int )(Math.random() * 6)+2;
		//2~7
		//System.out.println(randomStartX);
		//set box ,maybe multiple boxes
		while(boxSum<boxNeeded){
			//indicate place(1,0) means left (0,-1)means down, this does mean the index of box 
			randomWayX = (int )(Math.random()*3) -1;
			randomWayY = (int )(Math.random()*3) -1;
			System.out.println(randomWayX);
			System.out.println(randomWayY+"yy");
			this.validStartFlag = checkStartPoint(randomStartX,randomStartY,randomWayX,randomWayY);
			//should always valid 
			if(validStartFlag){
				//set player && box location for real
				if(map[randomStartX+randomWayX][randomStartY+randomWayY]=='W'){
					//if it's not wall then it's duplicated box place, then skip to next loop
					map[randomStartX][randomStartY] = 'P';
					map[randomStartX+randomWayX][randomStartY+randomWayY] = 'B';
					boxSum ++;
				}
				
			}
			//else{
			//	System.out.println("invalid box ? going next loop");
			//}
		}
		
		//now set target place
		int targetSum = 0;
		while(targetSum<boxNeeded){
			randomTX = (int)(Math.random()*10);
			randomTY = (int)(Math.random()*10);
			if(map[randomTX][randomTY]!='P'&&map[randomTX][randomTY]!='B'){
				map[randomTX][randomTY] = 'T';
				targetSum++;
			}
		}
		
		//now simulate path, minimize wall destroying. eg: when able to move box to get road..
		//so it's like step by step.
		
		int currentWallDestroyed = 0; 
		
		
		
		
		print();
		
		
		
		//difficulty for generating puzzle is decided by how many walls are passed through which becomes empty then
		// targets locate togther? more together more harder, since need to move box on target to another target 
		//to achieve less wall expansion
		//targets seperate?
		//need to guarantee one of them is 0
		//now it can guarantee the player & box place are valid
		
		
		
		
		//simulate path
		//hard point is cornering
		
		
				
	}
	
	//calculating distance function |x| + |y| instead of sqrt((y-y0)^2 + (x-x0)^2)
	//needs to consider situation that two method of distance equals eg: up and left would cause
	//same distance to target
	public int calDistance(int boxX,int boxY,int tarX,int tarY){
		return Math.abs(boxX-tarX) + Math.abs(boxY-tarY);
	}
	
	//check if all box are at targets
	public boolean checkFinished(int boxNeeded){
		int countOnTarget = 0;
		for(int i = 0;i<N;i++){
			for(int j = 0;j<M;j++){
				if(map[i][j] == 'O'){countOnTarget++;}
			}
		}
		return (countOnTarget == boxNeeded);
	}
	
	//x for start x index, y for start y index, rw for randomway eg:0 for up 1 for down
	public boolean checkStartPoint(int x ,int y,int rx,int ry){
		System.out.println("lll");
		if((rx==0 && ry != 0) ||(rx!= 0 && ry == 0)){
			//if touches edge, then start point is invalid
			if(rx + x== 0 || ry + y == 0 || rx + x ==9 || ry+ y == 9){return false;}
			else{return true;}
		}
		return false;
	}

	public static void print(){
		for(int i = 0; i< N; i++){
			for(int j = 0; j < M; j++)
				System.out.print(map[i][j]);
			System.out.println();
		}
		System.out.println();
	}
	
	
	
	


	public static void main(String[] args){
		TempGenerator a = new TempGenerator(3);
		System.out.println("doing");
	}

}

